抽象基类（Abstract Base Class）的作用

1. 为什么需要抽象基类？直接写具体类不行吗？
抽象基类（ABC）是设计契约，不是语法必需。 直接写具体类在简单场景可行，但在以下情况抽象基类显著优于具体类：
框架设计：定义稳定接口，强制子类实现关键方法
团队协作：明确约定类必须提供的功能，避免遗漏
类型检查：通过isinstance(obj, MyABC)验证对象是否符合接口规范
多态保证：确保不同实现可以互换使用
文档价值：清晰表达设计意图和类层次结构
核心区别：具体类关注"如何做"，抽象基类定义"做什么"。

2. 如果BaggingClassifier不实现fit方法，会有什么后果？
后果严重且多层面：
编译/实例化失败：如果继承自含@abstractmethod fit()的ABC，Python禁止实例化
训练功能缺失：无法进行自助采样、基分类器训练和集成学习核心流程
框架不兼容：无法与scikit-learn等机器学习框架的管道、交叉验证工具集成
运行时异常：即使通过语法检查，调用fit时也会抛出NotImplementedError或AttributeError
设计断裂：破坏Bagging作为集成学习算法的完整性，无法实际使用

3. 抽象基类中的pass可以用其他东西代替吗？比如return None？
可以但不推荐。 抽象方法体内可放置多种内容，但各有考量：

pass（推荐）：最简洁，明确表示"此处需要子类实现"
return None：语法正确但可能误导，让开发者误以为方法已有有效实现
raise NotImplementedError()：更明确地表示方法未实现
文档字符串：应该包含，用于说明方法契约
部分实现：可为所有子类提供通用逻辑，但需谨慎设计
最佳实践：抽象方法优先使用pass加清晰文档字符串；若需要通用逻辑，使用模板方法模式分离抽象与具体部分。

4. 假设我们想给所有分类器添加一个save_model()方法，应该在哪个类中添加？
应在分类器继承体系的最高合适抽象层级添加，具体取决于实现复杂度：
完全通用保存：若所有分类器能用相同方式保存（如pickle序列化），在BaseClassifier中添加具体实现
需要定制保存：若不同分类器需要不同保存逻辑，在BaseClassifier中：
添加抽象方法（子类必须实现各自逻辑）
或使用模板方法模式：提供公共骨架，定义protected抽象钩子方法供子类定制
作为Mixin：若保存功能横跨多种模型类型（分类器、回归器），可创建ModelSaverMixin类，通过多重继承添加